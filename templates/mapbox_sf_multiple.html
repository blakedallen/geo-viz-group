<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Display a map</title>
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
<script src="https://api.mapbox.com/mapbox-gl-js/v1.12.0/mapbox-gl.js"></script>
<link href="https://api.mapbox.com/mapbox-gl-js/v1.12.0/mapbox-gl.css" rel="stylesheet" />
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Goldman&display=swap" rel="stylesheet">


<style>
	body { margin: 0; padding: 0; }
	#map { position: absolute; top: 0; bottom: 0; width: 100%; }
</style>
</head>
<body>
  
<style>

.axisWhite {
  stroke: white;
}

.axisRed line{
  stroke: white;
}

.axisRed path{
  stroke: white;
}

.axisRed text{
  stroke: white;
}  

.map-overlay {
font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
position: absolute;
width: 25%;
top: 0;
left: 0;
padding: 10px;
}
 
.map-overlay .map-overlay-inner {
background-color: #fff;
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
border-radius: 3px;
padding: 10px;
margin-bottom: 10px;
}
 
.map-overlay h2 {
line-height: 24px;
display: block;
margin: 0 0 10px;
}
 
.map-overlay .legend .bar {
height: 10px;
width: 100%;
background: linear-gradient(to right, #0000CD, #fca107);
}
  
.map-overlay input {
background-color: transparent;
display: inline-block;
width: 100%;
position: relative;
margin: 0;
cursor: ew-resize;
}

.eleInfo {
  font-family: sans-serif;
  margin-top: 5px;
  margin-left: 5px;
  padding: 5px;
  width: 200px;
  border: 2px solid black;
  font-size: 20px;
  color: #222;
  background-color: #fff;
}
</style>  
<!-- background: linear-gradient(to right, #fca107, #7f3121); -->  
<div id="map"></div>

<div    id="control_panel"
        style="
        width: 630px;
        height:110px;
        font-family: 'Goldman', cursive;
        background-color: rgba(68, 68, 68, 0.79);
        color:#fefefe;
        padding:10px;
        text-align:left;
        top:0;
        right:0;
        position:absolute;
        overflow: hidden;"
        >

        
        <div id="chart1"></div>
        <div id="chart2"></div>
        <div id="chart3"></div>
        <h2>Sea Rise: <span id="numMeters">0</span> Meters | <span id="numFeet">0</span> Feet</h2>
        <!-- see how to update d3 via slider here: https://bl.ocks.org/tomshanley/3c49d036610853d380e3fcaf8d3f0b89 -->
        <input id="slider" type="range" min="0" max="80" step="1" value="0" 
          style="
            width:100%;
          "
        />


        <button
          id="hideButton"
          onclick="myFunction()"
        >Expand + </button>

        <button >Widget 1</button>
        <button >Widget 2</button>
        <button >Widget 3</button>
        <button >Widget 4</button>

        <div class="eleInfo"
          style="
            border: none;
            text-align:left;
            background-color: rgba(0,0,0,0);
            
          "

        >
          <div>Longitude: <span id='lng'></span></div>
          <div>Latitude: <span id='lat'></span></div>
          <div>Elevation: <span id='ele'></span></div>
        </div>
        <div id="legend" class="legend">
          <div class="bar"></div>
          <div>Sea Rise (meters)</div>
          <div id="geoviz"></div>
        </div>
    </div>
  
</div> 
  
<script>
var hidden = true;
myFunction = function() {
    var div = document.getElementById("control_panel");
    var button = document.getElementById("hideButton");
    if (hidden === false){
      hidden = true;
      div.style.height = "110px";
      button.innerText = "Expand +"
    } else{
      hidden = false;
      div.style.height = "620px";
      button.innerText = "Hide -"
    }
    
    if(div) {
        
    }
};



	// TO MAKE THE MAP APPEAR YOU MUST
	// ADD YOUR ACCESS TOKEN FROM
	// https://account.mapbox.com
	mapboxgl.accessToken = 'pk.eyJ1IjoiZXNjYWRhd2ciLCJhIjoiY2tmdmdrZGhkMTYzZDJ6czMyNWo0eWZmNCJ9.XAG-cdhWcLN2IEFAP6bCbg';
var map = new mapboxgl.Map({
container: 'map', // container id
//style: 'mapbox://styles/mapbox/streets-v11', // style URL
style: 'mapbox://styles/mapbox/satellite-streets-v11',
//37.86240503897279, -122.28268391890137
center: [-122.283, 37.862], // starting position [lng, lat]
zoom: 13, // starting zoom
pitch: 60
});

//actual gps coordinates used from elevation
// SF 38.2654816996427, -123.03271012693054 - 37.38640541626585, -121.67026118592658

//var iterations = 6;
var iterations = 2;
var bLat = -123.00;
var bLong = 37.0;
var count = 0;

var dist = 0.5

coordinates = [];
for (var i = 0; i < iterations; i += 1){
    for (var j = 0; j < iterations; j += 1){
    var x1 = bLat + i*dist;
    var y1 = bLong + j*dist;
    var x2 = x1 + dist;
    var y2 = y1 + dist;

    var d = [
        [x1, y2],
        [x2, y2],
        [x2, y1],
        [x1, y1],
    ];

    coordinates.push(d);
    }
}

// [stretches left and right, stretches up and down]
stretch_values = [
  [0.0, 0.0], // 1a
  [0.082, 0.08], // 1b
  [0.082, 0.08], // 1c
  [0.083, 0.080], // 1d
  [0.2275, 0.439], // 1e
  [0.2275, 0.439], // 1f
  [0.2275, 0.439], // 2a
  [0.2275, 0.439], // 2a
  [0.2275, 0.439], // 2b
  [0.2275, 0.439], // 2c
  [0.2275, 0.439], // 2d
  [0.2275, 0.439], // 2e
  [0.2275, 0.439], // 2f
  [0.2275, 0.439], // 3a
  [0.2275, 0.439], // 3b
  [0.2275, 0.439], // 3c
  [0.2275, 0.439], // 3d
  [0.2275, 0.439], // 3e
  [0.2275, 0.439], // 3f
  [0.2275, 0.439], // 4a
  [0.2275, 0.439], // 4b
  [0.2275, 0.439], // 4c
  [0.2275, 0.439], // 4d
  [0.2275, 0.439], // 4e
  [0.2275, 0.439], // 4f
  [0.2275, 0.439], // 5a
  [0.2275, 0.439], // 5b
  [0.2275, 0.439], // 5c
  [0.2275, 0.439], // 5d
  [0.2275, 0.439], // 5e
  [0.2275, 0.439], // 5f
  [0.2275, 0.439], // 6a
  [0.2275, 0.439], // 6b
  [0.2275, 0.439], // 6c
  [0.2275, 0.439], // 6d
  [0.2275, 0.439], // 6e
  [0.2275, 0.439], // 6f
];

// [move left, move down]
move_values = [
  [0.0, 0.0], // 1a
  [0.01, 0.0027], // 1b
  [0.01, 0.0003], // 1c
  [0.008, 0.0027], // 1d
  [0.0275, 0.008], // 1e
  [0.0275, 0.008], // 1f
  [0.0275, 0.008], // 2a
  [0.0275, 0.008], // 2a
  [0.0275, 0.008], // 2b
  [0.0275, 0.008], // 2c
  [0.0275, 0.008], // 2d
  [0.0275, 0.008], // 2e
  [0.0275, 0.008], // 2f
  [0.0275, 0.008], // 3a
  [0.0275, 0.008], // 3b
  [0.0275, 0.008], // 3c
  [0.0275, 0.008], // 3d
  [0.0275, 0.008], // 3e
  [0.0275, 0.008], // 3f
  [0.0275, 0.008], // 4a
  [0.0275, 0.008], // 4b
  [0.0275, 0.008], // 4c
  [0.0275, 0.008], // 4d
  [0.0275, 0.008], // 4e
  [0.0275, 0.008], // 4f
  [0.0275, 0.008], // 5a
  [0.0275, 0.008], // 5b
  [0.0275, 0.008], // 5c
  [0.0275, 0.008], // 5d
  [0.0275, 0.008], // 5e
  [0.0275, 0.008], // 5f
  [0.0275, 0.008], // 6a
  [0.0275, 0.008], // 6b
  [0.0275, 0.008], // 6c
  [0.0275, 0.008], // 6d
  [0.0275, 0.008], // 6e
  [0.0275, 0.008], // 6f
];

//scale our image coordinates
var s_lng = 1.0;
var s_lat = 1.0;


var image_count = iterations * iterations;
for (var i = 0; i < image_count; i += 1){

    //stretch our image
    var t_lng = 0.2275; //stretches left and right
    var t_lat = 0.439; //stretches up and down



    //translate top_left
    coordinates[i][0][0] -= stretch_values[i][0];
    coordinates[i][0][1] += stretch_values[i][1];

    //translate top right
    coordinates[i][1][0] += stretch_values[i][0];
    coordinates[i][1][1] += stretch_values[i][1];

    //translate bottom right 
    coordinates[i][2][0] += stretch_values[i][0];
    coordinates[i][2][1] -= stretch_values[i][1];

    //translate bottom left
    coordinates[i][3][0] -= stretch_values[i][0];
    coordinates[i][3][1] -= stretch_values[i][1];


    // //scale top left
    // coordinates[i][0][0] *= s_lng;
    // coordinates[i][0][1] *= s_lat;

    // //scale top right
    // coordinates[i][1][0] *= s_lng;
    // coordinates[i][1][1] *= s_lat;

    // //scale bottom right
    // coordinates[i][2][0] *= s_lng;
    // coordinates[i][2][1] *= s_lat;

    // //scale bottom left
    // coordinates[i][3][0] *= s_lng;
    // coordinates[i][3][1] *= s_lat;

    //move left
    coordinates[i][0][0] -= move_values[i][0];
    coordinates[i][1][0] -= move_values[i][0];
    coordinates[i][2][0] -= move_values[i][0];
    coordinates[i][3][0] -= move_values[i][0];

    //move down
    coordinates[i][0][1] -= move_values[i][1];
    coordinates[i][1][1] -= move_values[i][1];
    coordinates[i][2][1] -= move_values[i][1];
    coordinates[i][3][1] -= move_values[i][1];

    console.log(coordinates[i])
}

  
var mask_num = 80;

//generate our dataset
//TODO: load our dataset from json
masks = [];

r = ["1", "2", "3", "4", "5", "6", "7","8","9","10"]
c = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"]

var count = 0;
var city = "sfbay"

for (var row = 0; row < iterations; row += 1){
    for (var j = 0; j < iterations; j += 1){        
        for (var i = 0; i < mask_num; i += 1){
        var istr = i.toString();
        var d = {
            source:"source"+r[row]+c[j]+"_"+istr,
            id:"image"+r[row]+c[j]+"_"+istr,
            url:"/static/data/masks/"+city+r[row]+c[j]+"_"+istr+".png",
            coordinates: coordinates[count],
        }
        //console.log(coordinates[count])
        masks.push(d);
        }
        count += 1;
    }
}

console.log(masks);

map.on('load', function () {
  
  //add each of our masks
  for (var i = 0; i < masks.length; i++){
    var d = masks[i];
    
    //add images
    map.addSource(d["source"], {
    "type": "image",
    "url": d["url"],
    "coordinates": d["coordinates"],
    });
    
    map.addLayer({
    "id": d["id"],
    "source": d["source"],
    "type": "raster",
    "layout":{
      "visibility":"none",
    },
    "paint": {
      "raster-opacity": 0.5
      }
    });
  }



  var first_mask_id = masks[0]["id"];  

  let prev_idg = first_mask_id;
  //set our initial layer as visible
  //map.setLayoutProperty(prev_idg, 'visibility', 'visible');

  var prev_meter = 0;

  document
    .getElementById('slider')
    .addEventListener('input', function (e) {
      var meters = parseInt(e.target.value, 10);
      var numMeters = document.getElementById("numMeters");
      numMeters.textContent = meters;
      var numFeet = document.getElementById("numFeet");
      var feet = meters * 3.281;
      numFeet.textContent = feet.toFixed(1);

      for (var i = 0; i < iterations; i += 1){
        for (var j = 0; j < iterations; j += 1){
            let prev_idg = "image"+r[i]+c[j]+"_"+prev_meter.toString();
            map.setLayoutProperty(prev_idg, 'visibility', 'none');
        }
      }

      //map.setLayoutProperty(prev_idg, 'visibility', 'none');
      if (meters > 0){
        meters -= 1; 
        //let idg = "image_"+meters.toString();
        //console.log(idg);
        for (var i = 0; i < iterations; i += 1){
            for (var j = 0; j < iterations; j += 1){
                let idg = "image"+r[i]+c[j]+"_"+meters.toString();
                console.log(idg);
                map.setLayoutProperty(idg, 'visibility', 'visible');
            }
        }        
        //map.setLayoutProperty(idg, 'visibility', 'visible');
        //prev_idg = idg;

        prev_meter = meters;
      }
      
    });
  
 

  // contours to map
  map.addSource('contours', {
    type: 'vector',
    url: 'mapbox://mapbox.mapbox-terrain-v2'
  });
  map.addLayer({
    'id': 'contours',
    'type': 'line',
    'source': 'contours',
    'source-layer': 'contour',
    'layout': {
    // make layer visible by default
      'visibility': 'visible',
      'line-join': 'round',
      'line-cap': 'round'
    },
    'paint': {
      'line-color': '#877b59',
      'line-width': 1
    }
  });



});  
  

var marker = new mapboxgl.Marker({
  'color': '#314ccd'
});
  

function getElevation() {
  // make API request
  var query = 'https://api.mapbox.com/v4/mapbox.mapbox-terrain-v2/tilequery/' + lng + ',' + lat + '.json?layers=contour&limit=50&access_token=' + mapboxgl.accessToken;
  $.ajax({
    method: 'GET',
    url: query,
  }).done(function(data) {
    // Display the longitude and latitude values
    lngDisplay.textContent = lng.toFixed(2);
    latDisplay.textContent = lat.toFixed(2);
    // Get all the returned features
    var allFeatures = data.features;
    // Create an empty array to add elevation data to
    var elevations = [];
    // For each returned feature, add elevation data to the elevations array
    for (i = 0; i < allFeatures.length; i++) {
      elevations.push(allFeatures[i].properties.ele);
    }
    // In the elevations array, find the largest value
    var highestElevation = Math.max(...elevations);
    // Display the largest elevation value
    eleDisplay.textContent = highestElevation + ' meters';
  });
}

// Create variables for the latitude and longitude
var lng;
var lat;

map.on('click', function(e) {
  // When the map is clicked, set the lng and lat variables equal to the lng and lat properties in the returned lngLat object
  lng = e.lngLat.lng;
  lat = e.lngLat.lat;
  //ele = e.lngLat.ele;
  getElevation();
  marker.setLngLat(e.lngLat).addTo(map);

});
var lngDisplay = document.getElementById('lng');
var latDisplay = document.getElementById('lat');
var eleDisplay = document.getElementById('ele');


//Begin D3
var margin = {top: 60, right: 60, bottom: 50, left: 50},
    width = 600 - margin.left - margin.right,
    height = 400 - margin.top - margin.bottom;

// append the svg object to the body of the page
var svg = d3.select("#geoviz")
  .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

// Parse the Data
d3.csv("/data/simulated.csv", 
  function(data) {
  //////////
  // GENERAL //
  //////////

  // List of groups = header of the csv files
  var keys = data.columns.slice(1)

  // color palette
  var color = d3.scaleOrdinal()
    .domain(keys)
    .range(d3.schemeSet2);

  //stack the data?
  var stackedData = d3.stack()
    .keys(keys)
    (data)



  //////////
  // AXIS //
  //////////

  // Add X axis
  var x = d3.scaleLinear()
    .domain(d3.extent(data, function(d) { return d.year; }))
    .range([ 0, width ]);
  var xAxis = svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    .attr("class", "axisWhite")
    .call(d3.axisBottom(x).ticks(10))

  // Add X axis label:
  svg.append("text")
      .attr("text-anchor", "end")
      .attr("x", width)
      .attr("y", height+40 )
      .style("fill", "white")
      .text("Time (year)");

  // Add Y axis label:
  svg.append("text")
      .attr("text-anchor", "end")
      .attr("x", 0)
      .attr("y", -20 )
      .text("Pollution Level")
      .style("fill", "white")
      .attr("text-anchor", "start")

  // Add Y axis
  var max_pollution = 200000; //todo calculate 
  var y = d3.scaleLinear()
    .domain([0, max_pollution])
    .range([ height, 0 ]);
  svg.append("g")
    .attr("class", "axisWhite")
    .call(d3.axisLeft(y).ticks(10))



  //////////
  // BRUSHING AND CHART //
  //////////

  // Add a clipPath: everything out of this area won't be drawn.
  var clip = svg.append("defs").append("svg:clipPath")
      .attr("id", "clip")
      .append("svg:rect")
      .attr("width", width )
      .attr("height", height )
      .attr("x", 0)
      .attr("y", 0);

  // Add brushing
  var brush = d3.brushX()                 // Add the brush feature using the d3.brush function
      .extent( [ [0,0], [width,height] ] ) // initialise the brush area: start at 0,0 and finishes at width,height: it means I select the whole graph area
      .on("end", updateChart) // Each time the brush selection changes, trigger the 'updateChart' function

  // Create the scatter variable: where both the circles and the brush take place
  var areaChart = svg.append('g')
    .attr("clip-path", "url(#clip)")

  // Area generator
  var area = d3.area()
    .x(function(d) { return x(d.data.year); })
    .y0(function(d) { return y(d[0]); })
    .y1(function(d) { return y(d[1]); })

  // Show the areas
  areaChart
    .selectAll("mylayers")
    .data(stackedData)
    .enter()
    .append("path")
      .attr("class", function(d) { return "myArea " + d.key })
      .style("fill", function(d) { return color(d.key); })
      .attr("d", area)

  // Add the brushing
  areaChart
    .append("g")
      .attr("class", "brush")
      .call(brush);

  var idleTimeout
  function idled() { idleTimeout = null; }

  // A function that update the chart for given boundaries
  function updateChart() {

    extent = d3.event.selection

    // If no selection, back to initial coordinate. Otherwise, update X axis domain
    if(!extent){
      if (!idleTimeout) return idleTimeout = setTimeout(idled, 350); // This allows to wait a little bit
      x.domain(d3.extent(data, function(d) { return d.year; }))
    }else{
      x.domain([ x.invert(extent[0]), x.invert(extent[1]) ])
      areaChart.select(".brush").call(brush.move, null) // This remove the grey brush area as soon as the selection has been done
    }

    // Update axis and area position
    xAxis.transition().duration(1000).call(d3.axisBottom(x).ticks(5))
    areaChart
      .selectAll("path")
      .transition().duration(1000)
      .attr("d", area)
    }



    //////////
    // HIGHLIGHT GROUP //
    //////////

    // What to do when one group is hovered
    var highlight = function(d){
      
      // reduce opacity of all groups
      d3.selectAll(".myArea").style("opacity", .1)
      // expect the one that is hovered
      d3.select("."+d).style("opacity", 1)
    }

    // And when it is not hovered anymore
    var noHighlight = function(d){
      d3.selectAll(".myArea").style("opacity", 1)
    }



    //////////
    // LEGEND //
    //////////

    // Add one dot in the legend for each name.
    var size = 20
    svg.selectAll("myrect")
      .data(keys)
      .enter()
      .append("rect")
        .attr("x", 400)
        .attr("y", function(d,i){ return 10 + i*(size+5)}) // 100 is where the first dot appears. 25 is the distance between dots
        .attr("width", size)
        .attr("height", size)
        .style("fill", function(d){ return color(d)})
        .on("mouseover", highlight)
        .on("mouseleave", noHighlight)

    // Add one dot in the legend for each name.
    svg.selectAll("mylabels")
      .data(keys)
      .enter()
      .append("text")
        .attr("x", 400 + size*1.2)
        .attr("y", function(d,i){ return 10 + i*(size+5) + (size/2)}) // 100 is where the first dot appears. 25 is the distance between dots
        .style("fill", function(d){ return color(d)})
        .text(function(d){ return d})
        .attr("text-anchor", "left")
        .style("alignment-baseline", "middle")
        .on("mouseover", highlight)
        .on("mouseleave", noHighlight)

})

  
</script>


 
</body>
</html>